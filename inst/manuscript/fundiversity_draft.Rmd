---
title: 'fundiversity: a modular R package to compute functional diversity indices'
author:
  - name: Matthias Grenié
    email: matthias.grenie@idiv.de
    orcid_id: 0000-0002-4659-7522
    affiliation: idiv,uleipzig,cefe
    footnote: 1
  - name: Hugo Gruson
    email: hugo.gruson@normalsup.org
    orcid_id: 0000-0002-4094-1476
    affiliation: cefe,london
    footnote: 2

footnote:
  - code: 1
    text: "Corresponding Author"
  - code: 2
    text: "ORCID-ID <0000-0002-4659-7522>; ORCID-ID <0000-0002-4094-1476>"

date: "`r Sys.Date()`"
  
address:
  - code: idiv
    address: |
      German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig,
      Puschstraße 4,
      04103 Leipzig, Germany
  - code: uleipzig
    address: |
      Leipzig University, Ritterstraße 26, 04109 Leipzig, Germany
  - code: cefe
    address: |
      CEFE, 
      Université de Montpellier, CNRS, EPHE, IRD, Université Paul Valéry Montpellier 3, 
      Montpellier, France
  - code: london
    address: |
      Centre for Mathematical Modelling of Infectious Diseases, 
      London School of Hygiene & Tropical Medicine, 
      London, UK

abstract: |
  (max 350 words)
  
  1. Functional diversity is widely used and widespread. However, the main package used to compute functional diversity indices `FD` is not flexible and not adapted to the volume of data used in modern ecological analyses;
  
  2. We here present `fundiversity`, an R package that eases the computation of classical functional diversity indices. It leverages parallelization and memoization (storing some results in memory) to maximize efficiency with data with thousands of columns and rows.;
  
  3. In addition to being more flexible we did a performance comparison with packages that provide analog functions. `fundiversity` was always an order of magnitude quicker than alternative packages;
  
  4. `fundiversity` aims to be a lightweight efficient tool to compute functional diversity indices, that can be used in a variety of contexts. Because it has been designed following clear principles, it is easy to extend. We hope the wider community will adopt it and we welcome all contributions.

keywords:
  - biodiversity;
  - diversity facet;
  - R package;
  - functional biogeography;
  - functional ecology;
  - community ecology


header-includes:
  - \linenumbers
  - \usepackage{endfloat}

csl: methods-in-ecology-and-evolution.csl

bibliography: references.bib

layout: 3p

output: 
  rticles::elsevier_article:
    latex_engine: xelatex
    keep_tex: FALSE
    citation_package: default
  
journal: Methods in Ecology and Evolution
---

Running title (max 45 char.): fundiversity: functional diversity in R

Word count (3000-4000 incl. refs & captions): `r wordcountaddin::word_count()`


# Introduction

Functional diversity, the diversity of traits across scales, is a major facet of biodiversity [@Pavoine_Measuring_2011]. It has been widely used across ecological contexts [@Cadotte_species_2011] and has been shown to relate to ecosystem functioning [@Diaz_Vive_2001; @Leps_Quantifying_2006]. Many indices exist to characterize it across its three dimensions: richness, evenness, and divergence [@Pavoine_Measuring_2011]. To compute these indices in reproducible ways ecologists rely on computational tools able to crunch the numbers for thousands of species and thousands of sites. In the last few years, R has been the programming language of choice for ecologists [@Lai_Evaluating_2019; @RCoreTeam_language_2021]. The main tool available to compute functional diversity indices has been the `FD` package which has now accumulated more than 1200 citations [@Laliberte_FD_2014]. But `FD` has been released in 2009 and has since then only received minor updates that stopped in 2015. At the same time, best practices in software development have changed dramatically and new, higher-performance tools have emerged in the R ecosystem. Additionally, since 2009, the size of ecological datasets has grown exponentially [@Farley_Situating_2018; @Wuest_Macroecology_2020] and high performance computing (HPC) environments have become standard. There is therefore a dire need for a modern package to compute functional indices using state-of-the-art software development techniques and tools.

The main function of the `FD` package `dbFD()` lets users compute a dozen functional diversity indices in a single call from raw trait data [@Laliberte_FD_2014]. While great for exploratory analyses this can increase computation time when only a single index is needed. Furthermore, it does not enforce good practice in choosing beforehand the appropriate functional diversity index for the question(s) asked [@Legras_Functional_2018; @Mason_guide_2013; @Schleuter_user_2010]. It encourages the user to fish the functional diversity index that matches their predicted relationships (a form of p-hacking). This can lead the users to report all computed functional diversity indices even when there are no clear expectations on different functional diversity facets and/or to report correlated indices [@Legras_Functional_2018; @Mason_guide_2013; @McPherson_simulation_2018; @Schleuter_user_2010]. Computing all indices in a single function also makes long-term maintenance and addition of new indices harder. Finally, it adds an extra performance burden in the case where not all indices are needed.

The average size of datasets analyzed in ecology increased several folds in the last years [@Wuest_Macroecology_2020]. Considering that most analyses on functional diversity rely on null models that increase the data size by two or three orders of magnitude [@Gotelli_Null_1996], the need for efficient computation is paramount. First, any improvement of the algorithmic efficiency to compute functional diversity indices could save sensible amounts of time as it is repeated many times. For example, we noted that many R packages that compute functional diversity indices do not leverage matrix algebra with its libraries available that can cut the number of operations by orders of magnitude compared to using a loop directly in R. Second, functional diversity indices are generally computed over many mathematically independent sites. With the rise of multi-core computers, parallelization, i.e. splitting independent computations between different Computing Processor Units (CPUs), is becoming the norm. Very few functional diversity R packages propose parallelization which leaves the burden of implementing it to the user. There have been formidable new developments in this area in R over the last few years with the release `future` framework [@Bengtsson_unifying_2020] that allows the user to seamlessly parallelize computations on multiple cores on a single machine or across several machines, or even on a remote cluster without changing execution code. Third, computations on the same input can be cached through a process called memoization [@Wickham_memoise_2021]. This avoids wasting computing power on previously seen inputs. Several functional diversity indices rely on the computation of convex hulls across a multi-dimensional space [@Cornwell_TraitBased_2006; @Villeger_New_2008]. Caching the results of this costly computation could save time and computing power when measuring the diversity across similar sets, such as sites across a given region.

Increasing discussions are held regarding scientific software robustness and reliability in ecology [@Mislan_Elevating_2016a; @Poisot_Best_2015; @White_thoughts_2015; @Wilson_Good_2017]. Mainly because most ecologists are self-trained in programming [@Farrell_Power_2018], these virtuous practices are rarely applied in ecology [@Barraquand_Lack_2014]. For example, unit tests use predefined inputs to compare the software's outputs to expectations [@Poisot_Best_2015]. Unit tests have also become standard in R packages since the release of packages streamlining this process, such as `testthat` and `tinytest`. In part because of the relative recentness of the testing frameworks, very few R functional diversity packages provide unit tests to assess that the functions behave expectedly. Automatic tests of one's code are crucial when developing a tool for a wider audience as it may be used across different contexts.

We here propose a modern alternative to `FD` called `fundiversity` that benefits from modern development practices, necessary features for large-sized datasets (modularity, parallelization, and memoization), and greater flexibility. The package can be easily extended to accommodate additional diversity indices not covered by following a clear design pattern detailed in the next section. We then go through a use case to show how it can be used. We then compare the performance of `fundiversity` against similar packages.


# Main features of `fundiversity`

To ensure the consistency of its functions and to make it user-friendly, `fundiversity` follows clear design principles. In this section, we expose its distinctive features and principles.

To give maximum flexibility to the users, we tried to build `fundiversity` as modular as possible. Each function in `fundiversity` computes a single functional diversity index, as such if the user is interested in computing a single index, they only need to use a single function. All functions in `fundiversity` are prefixed with `fd_` to avoid conflict with similarly named functions in other packages, as it's becoming standard practice in newer R packages [@rOpenSci_rOpenSci_2021]. In line with its modularity, we focused on making the inputs and outputs of functions coherent. The functions compute functional diversity indices using two main information: a species by traits matrix and a site by species matrix, all functions accept these two objects as first arguments. Because the function outputs one diversity value per site the outputs are always structured similarly: one `site` column that contains the name of its sites and one column named as the computed index (such as `FRic` when computing functional richness). The shape of the output is predictable and easy to be combined with other data.

Parallelization can be an easy way to vastly decrease computation speed why leveraging the architecture of modern computers. By default almost all functions in `fundiversity` can be parallelized. `fundiversity` provides parallelization through the `future` backend [@Bengtsson_unifying_2020]. Parallelization is toggled through a single function call using `future::plan()` before using fundiversity functions. Thanks to the flexibility given by the future backend, the code to use won't change whether parallelizing across several cores on a single computer, across multiple computers, or on a remote high-performance cluster. The user has only to update the call to `future::plan()` to distribute computations on another infrastructure. Furthermore, the future backend provides load balancing so that no cores/units stay idle for too long and the parallelized tasks are split evenly. The packages contains a dedicated "Parallelization" vignette to guide the users through transforming unparallelized to parallelized code (accessible through `vignette("parallel", package = "fundiversity")`).

Because functional diversity indices can be computed repeatedly on the same data subset, such as in null models, we can leverage these repeated computations to reuse already computed indices. For example to compute functional richness (FRic) the convex hull of the input data has first to be identified, then the program needs to compute the volume of this convex hull. The first step, identifying the convex hull, takes the most time and as such, storing the results of each computed convex hull across a subset of data can vastly cut computation time for a little memory footprint. Memoization consists in doing exactly that, it trades a little of computer memory (keeping the convex hulls stored) for more computation speed. `fundiversity` leverages memoization for all complex computations such as convex hulls. By default, memoization is turned on for FRic, the intersection of convex hulls, and FDiv, however, it can sometimes create a memory bottleneck which slows down the overall computation. The default behavior can always be overridden through a change in the option `fundiversity.memoise`.

Packages depend on one another to avoid reinventing the wheel and thus reuse already developed functions. A higher number of dependencies means that a package requires more packages to be installed before its installation. While a high number of dependencies minimizes code replication, it also comes with a high price, because if a single dependency breaks then the whole package cannot be installed anymore [@Cox_Surviving_2019]. Inflated dependencies have been identified as a major risk in software and especially scientific software development [@Claes_maintainability_2014; @Cox_Surviving_2019]. `FD` only has four dependencies but other functional diversity packages have many more dependencies. This renders them quite brittle for the users after years of not being actively developed. `fundiversity` has been designed to only have minimal external dependencies, it currently depends on only four external packages: `future.apply` which depends only on two other packages, `Matrix` which is shipped with R, `geometry` and `vegan` on which `FD` also depends.

Because user flexibility is key, `fundiversity` has minimal assumptions on the input data structure. All its functions work with data frames, matrices, or sparse matrices alike. Sparse matrices are a different formalization of matrices that do not store explicitly the cells that contain zero. They offer a reduced memory footprint and optimized algebra library for computation [@Bates_Matrix_2021]. These matrices are thus specifically relevant for occurrence/abundance matrices that contain many zeros. If the used data have a high proportion of zeros, using sparse matrices can vastly decrease computational time in `fundiversity`.

As we underlined in the introduction, automatic software testing, while not 100% foolproof, is needed to increase the confidence in the behavior of functions. It is widespread in computer science but less in scientific software development. This means that software behavior is never assessed against known inputs to make sure it behaves in expected ways. It does not mean that the software is of poor quality, but rather that some simple errors could introduce unnoticed changes in the behavior of functions. Most packages that compute functional diversity indices do not include any form of automatic testing. We do want to point out that most ecologists never received formal training in software development hence the lack of tests [@Farrell_Power_2018]. We designed `fundiversity` with many unit tests from the beginning, executing at least every single line of code once (i.e. achieving coverage of 100%).

`fundiversity` only computes alpha functional diversity indices, because other packages exist to compute other types of functional diversity indices [Hill numbers, @Li_hillR_2018; beta-diversity indices, Baselga_betapart_2012]. We focused on indices available through the `dbFD()` function in the `FD` package and on indices that could benefit from faster implementation. fundiversity contains the following alpha functional diversity indices: functional richness (FRic), functional dispersion (FDis), functional divergence (FDiv), functional evenness (FEVE), and Rao's quadratic entropy (Q). `fundiversity` also contains a beta-diversity index as it can be useful to compare functional richness between sites.

| Function Name         | Index Name                   | Source                        | Parallelizable | Memoizable |
|:----------------------|:-----------------------------|:------------------------------|:--------------:|:----------:|
| `fd_fdis()`           | Functional Dispersion (FDis) | @Laliberte_distancebased_2010 | Yes            | No         |
| `fd_fdiv()`           | Functional Divergence (FDiv) | @Villeger_New_2008            | Yes            | Yes        |
| `fd_feve()`           | Functional Evenness (FEve)   | @Villeger_New_2008            | Yes            | No         |
| `fd_fric()`           | Functional Richness (FRic)   | @Villeger_New_2008            | Yes            | Yes        |
| `fd_fric_intersect()` | Functional $\beta$-diversity | @Villeger_Decomposing_2013    | Yes            | Yes        |
| `fd_raoq()`           | Rao's Quadratic Entropy (Q)  | @Rao_Diversity_1982           | No             | No         |

Table: List of functions available in `fundiversity` to compute functional diversity indices. The two last columns specify which functions are parallelizable and memoizable.


# Case Study

Now that we described the main features of fundiversity, we are going to show how to use it in practice when computing functional diversity indices. As an example dataset, we included in `fundiversity` site-species and trait data from @Nowak_Data_2019. It is accessible through the use of the `data(..., package = "fundiversity")` function. This dataset describes the presence of bird species in South America at different elevations and four morphological traits.

The trait values show species in rows (species are specified as row names) and traits in columns with trait names as column names. Similarly, the site-species matrix contains sites as rows (site names are row names) and species as columns (species names are column names).

```{r load_data}
data("traits_birds",  package = "fundiversity")
data("site_sp_birds", package = "fundiversity")

head(traits_birds)
head(site_sp_birds)[, 1:3]
```

Now we obtained trait and occurrence data we need to compute the trait dissimilarity between each pair of species. As all traits are quantitative we first Z-score them, then we compute the Euclidean distance between pairs of species.

```{r trait_dissmilarity}
z_traits = scale(traits_birds, center = TRUE, scale = TRUE)

trait_distance = as.matrix(dist(z_traits))
```

We can then compute the functional richness of each index at each location. To do so we are using the `fd_fric()` function. It expects quantitative trait values as the first argument and a site-species matrix as the second argument.

```{r fric}
library("fundiversity")

birds_fric = fd_fric(z_traits, site_sp_birds)

head(birds_fric)
```

All other functions in `fundiversity` use a similar structure, the first input is trait data the second one is a site-species matrix. For Rao's quadratic entropy computed through `fd_raoq()` functional dissimilarities can be specified as the third argument:

```{r raoq}
# With functional dissimilarity
birds_raoq = fd_raoq(traits = NULL, site_sp_birds, dist_matrix = trait_distance)

# With trait values
birds_raoq_2 = fd_raoq(z_traits, site_sp_birds)

# Both options give the same results
identical(birds_raoq, birds_raoq_2)
```

If all traits are not quantitative it is possible to transform them back into independent traits through the use of Gower's distance [@Gower_general_1971; and its extensions: @Podani_Extending_1999, @Pavoine_challenge_2009;] then applying multivariate analysis to obtain orthogonal dimensions [@Maire_How_2015].


# Performance Comparison

To test the actual performance improvements realized by `fundiversity`, we compared computation time on standardized datasets across similar functions in other packages. We only compared "original" packages that provide actual functions and not wrappers that depend on other packages to compute functional diversity indices. We identified 6 packages that computed similar indices to `fundiversity`. Most indices are computed by the `FD::dbFD()` function but the comparison would be unfair as the function computes many indices in a single call while functions in `fundiversity` only compute single indices. We considered functions from: `adiv` [@Pavoine_adiv_2020], `BAT` [@Cardoso_BAT_2015], `betapart` [@Baselga_betapart_2012], `hillR` [@Li_hillR_2018], `mFD` [@Magneville_mFD_2022], and `FD` [@Laliberte_FD_2014] (see Table 2 for the correspondence between packages). A continuously updated version of this section can be found in the performance comparison vignette within the `fundiversity` package with `vignette("performance", package = "fundiversity")`.

| Index Name                   | `fundiversity` Functions | Functions in other packages |
|:-----------------------------|:-------------------------|-----------------------------|
| Functional Dispersion (FDis) | `fd_fdis()`              | `BAT::dispersion()`\linebreak`FD::fdisp()`\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fdis")` |
| Functional Divergence (FDiv) | `fd_fdiv()`              | `mFD::alpha.fd.multidim(..., ind_vect = "fdiv")`
| Functional Evenness (FEve)   | `fd_feve()`              | `mFD::alpha.fd.multidim(..., ind_vect = "feve")`
| Functional Richness (FRic)   | `fd_fric()`              | `BAT::alpha()` (tree)\linebreak`BAT::hull.alpha()` (hull)\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fric")` |
| Rao's Quadratic Entropy (Q)  | `fd_raoq()`              | `adiv::QE()`\linebreak`BAT::rao()`\linebreak`hillR::hill_func()`\linebreak`mFD::alpha.fd.hill(..., q = 2, tau = "max")`
| Functional $\beta$-diversity | `fd_fric_intersect()`    | `betapart::functional.beta.pair()`\linebreak`hillR::hill_func_parti_pairwise()`

Table: List of functions available in `fundiversity` to compute functional diversity indices and corresponding functions in other packages. The name of the package is indicated before the `::` while the name of the functions (including specified arguments) follows.

For testing purposes, we used datasets of increasing size with the number of species being 200, 500, or 1000; the number of traits 2, 4, or 10; the number of sites 50, 100, or 500. For each set of parameters, we generated a fictional site-species matrix and site-trait matrix, comprised only of continuous trait data. We used these simulated data to perform benchmarks across comparable functions among the selected packages. The benchmark ran 30 times through the `bench` package [@Hester_bench_2021]. A summary of the results of the benchmark can be seen in Fig. \ref{fig1}. Full results detailing the timings for each combination of parameters and functions are available in the Supplementary Material.

```{r fig1-benchmark-results, out.width="100%", fig.align='center', fig.cap="\\label{fig1}Timing comparison across functional diversity indices between packages. Each point represents the execution time of one run using a simulated dataset, the points are transparent and jittered to avoid overplotting. We here show the performance results considering only a single set of parameters with 4 traits, 500 species, and 100 sites, repeated 30 times.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "fig1_sequential_benchmark.png")
)
```

We see that for all the indices and functions tested, `fundiversity` is at least an order of magnitude faster than alternative packages. For functional dispersion, `fundiversity` is two orders of magnitude faster compared to `BAT` and `mFD`. For functional divergence, `fundiversity` is one order of magnitude faster than `mFD`. For functional evenness, `fundiversity` is two orders of magnitude faster than `mFD` with sequential and parallelized versions having similar performances. For Rao's quadratic entropy, `fundiversity` is one order of magnitude faster than `hillR` and `mFD`, two orders faster than `adiv`, and three orders of magnitude faster than `BAT`. For functional richness, `fundiversity` is half an order of magnitude faster than the hull version of `BAT`, as well as one and a half order of magnitude faster than its tree version and `mFD`. For functional richness intersection (beta functional diversity), `fundiversity` is two orders of magnitude faster than `betapart` and `hillR`.

```{r fig2-benchmark-parallel, out.width="100%", fig.align='center', fig.cap="\\label{fig2}Timing comparison between parallel and sequential version of fundiversity functions across functional diversity indices. Each point represents the execution time of one run using simulated datasets with fixed properties (4 traits, 100 sites, 500 species), the points are transparent and jittered to avoid overplotting. The parallel version ran across 6 cores.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "fig2_parallel_benchmark.png")
)
```

On average the parallelized versions of `fundiversity` functions executed an order of magnitude faster than the sequential versions. For functional richness we even observed a difference of two orders of magnitude. However, for functional dispersion, parallelization increased overall computation time. This may be due to inherent parallelization issues: there is an overhead cost when splitting tasks across multiple cores of a computer. The efficiency of parallelization depends on the difficulty of the tasks that are split between cores. In the case of functional richness, the main task is computing the convex hull, which is computationally costly, that is why parallelization increase performance in this case. While computing functional dispersion is simpler, and as such, does not benefit from being split across different cores.

One important note regarding parallelization in `fundiversity`, is that it is important to avoid doing both memoization and parallelization simultaneously. Memoization creates a cache to avoid recomputing results, and the cache may be corrupted if several cores access the same results at the same time. We noticed that toggling memoization while performing parallelization severely increase total computational time, compared to sequential performance.


# Conclusion

We proposed a modern alternative R package to compute functional diversity indices. This package follows current best development practices and leverages modern features like parallelization and memoization to increase its performance. This is only made possible by recent developments which were for the most part not available at the time when alternative packages came out. `fundiversity` does not propose to replace the entire toolkit for the researcher interested in functional diversity (including the upstream selection of the traits and building of a functional space) but instead focuses on improving the most computationally costing step: computing functional diversity indices. We hope it will be a useful contribution to this toolkit. This package aims to always be a work in progress and we welcome contributions from interested users and developers.


# Acknowledgements

MG gratefully acknowledges the support of iDiv funded by the German Research Foundation (DFG--FZT 118, 202548816).

# Authors' Contributions

Our authors' statement follows the Contributor Roles Taxonomy (CRediT, <https://casrai.org/credit/>). **Matthias Grenié**: Conceptualization, Methodology, Software, Resources, Writing - Original Draft, Writing - Review & Editing, Supervision. **Hugo Gruson**: Conceptualization, Methodology, Software, Writing - Review & Editing.

# Data Availability

`fundiversity` is available on CRAN through `install.packages("fundiversity")` as well as on GitHub at <https://github.com/Bisaloo/fundiversity>, for archival all releases are available on Zenodo at <https://doi.org/10.5281/zenodo.4761754>. The data used in this article are available from the package, through `data(package = "fundiversity")` call.


# Supplementary Information

```{r fig-s1-benchmark-full, out.width="100%", fig.align='center', fig.cap="\\label{figs1}Performance comparison across functions of different packages over a range of parameters (number of traits, species, and sites). Note that each combination of parameters ran 30 iterations. The lines show trends of execution time in function of number of sites of the input dataset.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "s1_external_comparison_full.png")
)
```


```{r fig-s2-internal-full, out.width="100%", fig.align='center', fig.cap="\\label{figs2}Performance comparison across internal functions over a range of parameters (number of traits, species, and sites) and different parallelization parameters. Note that each combination of parameters ran 20 iterations. The lines show trends of execution time in function of number of sites of the input dataset.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "s1_external_comparison_full.png")
)
```

# References
