---
title: 'fundiversity: a modular R package to compute functional diversity indices'
author:
  - name: Matthias Grenié
    email: matthias.grenie@idiv.de
    orcid_id: 0000-0002-4659-7522
    affiliation: idiv,cefe
    footnote: 1
  - name: Hugo Gruson
    email: hugo.gruson@normalsup.org
    orcid_id: 0000-0002-4094-1476
    affiliation: cefe,london
    footnote: 2

footnote:
  - code: 1
    text: "Corresponding Author"
  - code: 2
    text: "ORCID-ID <0000-0002-4659-7522> ORCID-ID <0000-0002-4094-1476>"

date: "`r Sys.Date()`"
  
address:
  - code: idiv
    address: |
      German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig,
      Puschstraße 4,
      04103 Leipzig, Germany
  - code: cefe
    address: |
      CEFE, 
      Université de Montpellier, CNRS, EPHE, IRD, Université Paul Valéry Montpellier 3, 
      Montpellier, France
  - code: london
    address: |
      Centre for Mathematical Modelling of Infectious Diseases, 
      London School of Hygiene & Tropical Medicine, 
      London, UK

abstract: |
  (max 350 words)
  
  1. Functional diversity is widely used and widespread. However the main package used to compute functional diversity indices `FD` is not flexible and not adapted to the volume of data used in modern ecological analyses;
  
  2. We here present `fundiversity`, an R package that ease the computation of classical functional diversity indices. It is modular, leverage on parallelization and memoization (storing some results in memory) to maximize efficiency with data with thousands of columns and rows.;
  
  3. In addition of being more flexible we did a performance comparison with packages that provide analog functions. `fundiversity` was always at an order of magnitude quicker. DEVELOP THE INFLUENCE OF DATASET SIZE ON COMPUTATION SPEED (+ MEMORY CONSUMPTION?);
  
  4. `fundiversity` aims to be an efficient tool to compute functional diversity indices, in order to be used in a variety of context. Because it has been designed following clear principles, it is easy to extend. We hope the wider community will adopt it and we welcome all contributions.

keywords:
  - biodiversity;
  - diversity facet;
  - R package;
  - functional biogeography;
  - functional ecology;
  - community ecology


header-includes:
  - \linenumbers
  - \usepackage{endfloat}

csl: methods-in-ecology-and-evolution.csl

bibliography: references.bib

layout: 3p

output: 
  rticles::elsevier_article:
    latex_engine: xelatex
    keep_tex: FALSE
  
journal: Methods in Ecology and Evolution
---

Running title (max 45 char.): fundiversity: functional diversity in R

Word count (3000-4000 incl. refs & captions): `r wordcountaddin::word_count()`


# Introduction

Functional diversity, the diversity of traits across scales, is a major facet of biodiversity [@Pavoine_Measuring_2011]. It has been shown to relate to ecosystem functioning [@Diaz_Vive_2001; @Leps_Quantifying_2006]. Since its definition it has been widely used across ecological contexts [@Cadotte_species_2011]. Many indices exist to characterize it across its three dimensions: richness, evenness, divergence [@Pavoine_Measuring_2011]. To compute these indices in reproducible ways ecologists rely on computational tools able to crunch the numbers for thousands of species and thousands of sites. In the last few years, R has been the programming language of choice for ecologists [@Lai_Evaluating_2019; @RCoreTeam_language_2021]. The main tool available to compute functional diversity indices has been the `FD` package which has now accumulated more than 1200 citations [@Laliberte_FD_2014]. The `FD` package has not been updated since 2015 and it does not offer the flexibility needed by some users. Ecology increasingly use larger datasets which require more efficient computations [@Farley_Situating_2018; @Wuest_Macroecology_2020]. The tools to compute functional diversity indices are thus in great need of improvement.

**Need for modularity in computation**. The main function of the `FD` package `dbFD()` lets the users compute a dozen functional diversity indices in a single call from raw trait data [@Laliberte_FD_2014]. While great for exploratory analyses this can increase computation time when only a single index is needed. Furthermore, it does not enforce good practice in choosing beforehand the appropriate functional diversity index for the question(s) asked [@Legras_Functional_2018; @Mason_guide_2013; @Schleuter_user_2010]. It encourages the user to fish the functional diversity index that matches their predicted relationships. This can lead the users to report all computed functional diversity indices even when there no clear expectations on different functional diversity facets and/or to report correlated indices [@Legras_Functional_2018; @Mason_guide_2013; @McPherson_simulation_2018; @Schleuter_user_2010]. Building the tool so that indices can be computed independently of one another has the added benefit to make maintenance and the addition of new indices easier.

**Need for faster computation (with three solutions: algorithmic efficiency, parallelization, memoization)**. The average size of datasets analyzed in ecology increased several folds in the last years [@Wuest_Macroecology_2020]. Considering that most analyses on functional diversity rely on null models that increase the data size by two or three orders of magnitude [@Gotelli_Null_1996], the need for efficient computation is paramount. First, any improvement of the algorithmic efficiency to compute functional diversity indices could save sensible amount of time as its repeated  many times. For example we noted that many R packages that compute functional diversity indices do not leverage on matrix algebra with its libraries available that can cut the number of operations by orders of magnitude. Second, functional diversity indices are generally computed over many mathematically independent sites. With the rise of multi-core computers, parallelization, i.e. splitting independent computations between independent Computing Processor Units (CPUs), is becoming the norm. Very few functional diversity R packages propose parallelization which leaves the burden of implementing it to the user. Furthermore, when they do, they do not rely on recently released `future` framework [@Bengtsson_unifying_2020] that allows the user to seamlessly parallelize her computations on multiple cores on a single machine, or across several machine, or even on a remote cluster. Third, computation on exact same input can be cached through a process called memoization [@Wickham_memoise_2021]. This avoid wasting computing power on previously seen inputs. Several functional diversity indices rely on the computation of convex hulls across a multi-dimensional space [@Cornwell_TraitBased_2006; @Villeger_New_2008]. Caching the results of this costly computation could save time and computing power when measuring the diversity across a similar sets, such as sites across a given region.

**Need for reliable software**. Increasing discussion are held regarding scientific software robustness and reliability in ecology [@Mislan_Elevating_2016a; @Poisot_Best_2015; @White_thoughts_2015; @Wilson_Good_2017]. Mainly because most ecologists are self-trained in programming, these virtuous practices are rarely applied in ecology [@Barraquand_Lack_2014]. For example, unit tests use predefined inputs to compare the software’s outputs to expectations [@Poisot_Best_2015]. To our knowledge very few R functional diversity packages provide unit tests to assess that the functions behave in the expected manner. Automatic tests of one’s code are crucial when developing a tool for the wider audience as it may be used in many different contexts. 

**What we do here**. We here propose a modern alternative to `FD` called `fundiversity` that benefits from modern development practices, needed features for large sized dataset (modularity, parallelization, and memoization), and greater flexibility. The package can be easily extended to accommodate additional diversity indices not covered by following a clear design pattern detailed in the next section.


# Main features of `fundiversity`

To ensure the consistency of its functions and to make it user-friendly, `fundiversity` follows clear design principles. In this section, we expose its distinctive features and principles.

**Modular**. To give a maximum flexibility to the users, we tried to make `fundiversity` as modular as possible.  Each function in `fundiversity` computes a single functional diversity index and doesn't require change of arguments to compute more. So that if the user is interested in computing a single index, she only needs to use a single function. All functions in `fundiversity` are prefixed with `fd_` to avoid conflict with similar named functions in other packages, as it's becoming standard practice in newer R packages [@rOpenSci_rOpenSci_2021]. In line with its modularity, we focused on making the inputs and outputs of functions coherent. The functions compute functional diversity indices using two main information: a species by traits matrix and a site-species matrix, as such all functions accept these two objects as first arguments. Because the function outputs one diversity value per site the outputs is always structured similarly: one `site` column that contains the name of its site and one column names in function of the computed index (such as `FRic` when computing functional richness). As such, the shape of the output is predictable and easy to be combined with other information.

**Parallelization**. Parallelization can be an easy way to vastly decrease computation speed why leveraging on the architecture of modern computers. By default almost all functions in `fundiversity` can be parallelized. `fundiversity` provides parallelization through the `future` backend [@Bengtsson_unifying_2020]. Parallelization is toggled through a single function call using `future::plan()` before using fundiversity functions. Thanks to the flexibility given by the future backend, the code to use won't change whether parallelizing across several cores on a single computer, across multiple computers, or on a remote high performance cluster. The user has only to update the call to `future::plan()` to distribute her computations on another infrastructure. Furthermore the future backend provides load balancing so that no cores/units stays idle for too long and the parallelized tasks are split evenly.

**Memoization**. Because functional diversity indices can be computed repeatedly on the same data subset, such as in null models, we can leverage these repeated computations to reuse already computed indices. For example to compute functional richness (FRic) the first step is to compute the convex hull of the input data then the program needs to compute the volume of this convex hull. The first step, identifying the convex hull, takes the most time and as such, storing the results of each computed convex hull across a subset of data can vastly cut  computation time for a little memory footprint. Memoization consists in doing exactly that, it trades a little of computer memory (keeping the convex hulls stored) for more computation speed. `fundiversity` leverages on memoization for all complex computations such as convex hulls. By default, memoization is turned on for FRic, intersection of convex hulls, and FDiv, however it can sometimes create memory bottleneck which slow down the overall computation. The default behavior can always be overridden through a change in the option `fundiversity.memoise`.

**Minimal External Dependencies**. Packages depend on one another to avoid reinventing the wheel and thus reuse already developed functions. A higher number of dependencies means that a package require more packages to be installed prior to its own installation. While a high number of dependencies minimizes code replication, it also comes with high price, because if a single dependency breaks than the whole package cannot be installed anymore. Inflated dependencies has been identified as a major risk in software and especially scientific software development [@Claes_maintainability_2014]. `FD` only has four dependencies but other functional diversity packages have many more dependencies. This render them quite brittle for the users after years of not being actively developed. `fundiversity` has been designed to only have minimal external dependencies, it currently depends on only four external packages: `future.apply` which depends only on two other packages, `Matrix` which is shipped with R, `geometry` and `vegan` on which `FD` also depends. [INDICATE ALSO THE NUMBER OF DEPENDENCIES ACCORDING TO `pkgdepends`???]

**Agnostic of used input**. Because user flexibility is key, `fundiversity` has minimal assumptions on the input structure, all its functions work with data frames, matrices or sparse matrices alike. While other packages sometimes work only with a single input type. Sparse matrices specifically optimized for occurrence/abundance matrices that have many zeros. In this case, working with sparse matrices can vastly decrease computational time.

**Well tested**. As we underlined in introduction, automatic software testing, while not 100% foolproof, is needed to increase the confidence in the behavior of functions. It is widespread in computer science but less in scientific software development. This means that software behavior is never assessed against known inputs to make sure it behaves in expected ways. It does not mean that the software is of poor quality, but rather that some simple errors could introduce unnoticed changes in the behavior of functions. Most packages that compute functional diversity indices do not include any form of automatic testing. We do want to point out that most ecologists never received formal training in software development hence the lack of tests (REF). We designed `fundiversity` with many unit tests from the beginning, executing at least every single line of code once (i.e. a code coverage of 100%).

**Main indices**. `fundiversity` only computes alpha functional diversity indices, because other packages exist to compute other types of functional diversity indices (CITE BETAPART AND HILLR). We focused on indices available through the `dbFD()` function in the `FD` package and on indices that could leverage on faster implementation. fundiversity contains the following alpha functional diversity indices: functional richness (FRic), functional dispersion (FDis), functional divergence (FDiv),  functional evenness (FEVE), and Rao’s quadratic entropy (Q). `fundiversity` also contains a beta-diversity index as it can be useful to compare functional richness between sites, and no implementation was available at the time it was developed (but see `betapart` newest functions).

```{r child=here::here("man", "rmdchunks", "_fundiversity_functions.Rmd"), fig.cap="Table of available functions in fundiversity. Each column indicates which ones are parallelizable and which ones are memoizable."}
```

[This table should probably include the name in full of the computed index? What additional info would we like to display there?]

[Should we include the comparative table of packages?]

# Case Study

Now that we described the main features of fundiversity, we are going to show how to use in practice when computing functional diversity indices. As an example dataset we included in `fundiversity` site-species and trait data from @Nowak_Data_2019. It is accessible through the use of the `data(..., package = "fundiversity")` function. This dataset describes the presence of bird species in South America at different elevations and four morphological traits. We are interested in knowing how different aspects of functional diversity of birds vary with elevation.

The trait values show species in rows (species are specified as row names) and traits in columns with trait names as columns names. Similarly site-species matrix contains sites as rows (site names are row names) and species as columns (species names are column names).

```{r load_data}
data("traits_birds",  package = "fundiversity")
data("site_sp_birds", package = "fundiversity")

head(traits_birds)
head(site_sp_birds)[, 1:3]
```

Now we obtained trait and occurrence data we need to compute the trait dissimilarity between each pair of species. As all traits are quantitative we first Z-score them, then we compute the Euclidean distance between pair of species.

```{r trait_dissmilarity}
z_traits = scale(traits_birds, center = TRUE, scale = TRUE)

trait_distance = as.matrix(dist(z_traits))
```

We can then compute the functional richness of each indices at each location. To do so we are using the `fd_fric()` function. It expects quantitative trait values as first argument and a site-species matrix as a second argument. 

```{r fric}
library("fundiversity")

birds_fric = fd_fric(z_traits, site_sp_birds)

head(birds_fric)
```

All other functions in `fundiversity` use a similar structure, the first input is trait data the second one is a site-species matrix. For Rao's quadratic entropy computed through `fd_raoq()` functional dissimilarities can be specified as the third argument:

```{r raoq}
# With functional dissimilarity
birds_raoq = fd_raoq(traits = NULL, site_sp_birds, dist_matrix = trait_distance)

# With trait values
birds_raoq_2 = fd_raoq(z_traits, site_sp_birds)

# Both options give the same results
identical(birds_raoq, birds_raoq_2)
```

If all traits are not quantitative it is possible to transform them back into independent traits through the use of Gower's distance [@Gower_general_1971; and its extensions: @Podani_Extending_1999, @Pavoine_challenge_2009;] then applying a multivariate analysis to obtain orthogonal dimensions [@Maire_How_2015].


# Performance Comparison

In order to track to what extent the additional functionalities provided fundiversity actually helped in cutting the computation time we compared computation time on standardized datasets across similar functions in other packages. We only compared to "original" packages that provide actual functions and not wrappers that depends on other packages to provide computation of functional diversity indices. We identified Y similar packages. Most indices are included `FD::dbFD()` function but the comparison would be unfair as the function computes many indices in a single call while functions in fundiversity only compute single indices. An updated version of this section can be found through the performance comparison vignette within the fundiversity package with the `vignette("performance", package = "fundiversity")`. Only for Rao’s quadratic entropy (and for beta functional richness intersection?).

For test purposes we used datasets of increasing complexity (increasing number of species, increasing number of traits, increasing number of sites, draw performance in a 3D space?).

Plots of comparison between packages

Note on the efficiency of different functions (within fundiversity) with dataset of increasing complexity.

Note on the effect of parallelization on computing speed.

Note on the effect of memoization on computing speed.

[Realistic trait and site-species data? compare across packages like Rao's between packages, FRic between packages + with/without parallelization & memoization.]

# Conclusion

We proposed a modernized alternative R package to compute functional diversity indices. This package leverages on modern functionalities like parallelization and memoization to increase its performance. It tries to follow best software development practices. By no means we are willing to point fingers at other packages but rather we decided to build it from scratch following clear design principles from the ground up. We hope to be a useful contribution in the field of packages that allow to compute functional diversity indices. This package is always a work in progress and we welcome contributions from interested users and developers.

# Acknowledgements

MG gratefully acknowledges the support of iDiv funded by the German Research Foundation (DFG–FZT 118, 202548816).


# Authors' Contributions

MG and HG both conceived the package. MG led the writing of the manuscript. Both authors contributed critically to the drafts and gave final approval for publication.


# Data Availability

`fundiversity` is available on CRAN through `install.packages("fundiversity")` as well as on GitHub at https://github.com/Bisaloo/fundiversity, for archival all releases are available on Zenodo at https://doi.org/10.5281/zenodo.4761754. The data used in this article are available from the package, through `data(package = "fundiversity")` call.


# References
